'''
测试岗2023-03-13 1.归零

时间限制：3000 MS
内存限制：589824 KB

题目描述：
小A最近学习到一种新的运算，叫异或，运算符记为xor。
这是对两个相向长度的二进制串 (仅含有0或1的字符串)进行的运算，相同位上对应的数字如果不同则该位运算结果为1。否则为0。
现在小A手上有一个二进制串s，他想让这个二进制串异或上若干个长度相等且所有的1连续的二进制串(如000111,1100,010,1等，但01010,101等不合法)，使得s所有位都为0。
小A想知道最少需要进行多少次异或运算?

输入描述：
第一行一个正整数T，表示有T组数据；
接下来每一组数据对应一行，首先输入x，表示该二进制串长度；之后输入一个长度为x的二进带串。中间用空格隔开。
1<=x<=50000，1<=T<=100。

输出描述：
输出T行，每一行一个整数，表示该数据下的最小异或次数。

样例输入：
2
8 00011101
1 0

样例输出：
2
0
'''
# 思路
'''
贪心就完事儿了。
假设异或串的1覆盖且多于原串的连续的1的区域，则结果在减少一块目标连续1的区域的基础外，要么不增加数量，要么增加一块或两块连续的1的区域。
所以只需计算连续1的区域个数，每次去掉一个区域的1，即为所求。
'''
T = int(input())
res = [0] * T
for i in range(T):
    line = input().split(' ')
    length, bistring = int(line[0]), line[1]
    count = 0
    for j in range(length - 1):
        if bistring[j] == '1' and bistring[j + 1] == '0':
            count += 1
    if bistring[-1] == '1':
        count += 1
    res[i] = count

for num in res:
    print(num)